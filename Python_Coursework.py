import numpy as np
import pandas as pd
import evaluation as ev
from timeit import default_timer as timer
import multiprocessing as mp
import matplotlib.pyplot as plt

# Read CSV and assign the index to Gift ID
gifts = pd.read_csv("gifts.csv")

# Use Pandas to create 3 samples from the data and convert them to numpy arrays
sample1 = gifts.sample(n=10, random_state=1).reset_index()
sample2 = gifts.sample(n=100, random_state=2).reset_index()
sample3 = gifts.sample(n=1000, random_state=3).reset_index()
sample1 = np.array(sample1.drop("index", axis=1))
sample2 = np.array(sample2.drop("index", axis=1))
sample3 = np.array(sample3.drop("index", axis=1))


# Algorithm 1: Random Search
def random_search(sample, maximum_number):
    """
    Generate different solution randomly and compare wrw to find the best solution
    """
    # Create empty array and list to store the best WRW and solution returned by each run (30 values in total)
    inner_wrw_list = np.zeros(30)
    inner_sbest_list = []

    # Collect 30 results with different random seed
    for s in range(30):
        np.random.seed(s)
        wrw_list = np.zeros(maximum_number + 1)
        sbest_list = []

        # Generate the first solution randomly ant calculate the WRW
        # Use while loop and try except to deal with the weight limit error
        while True:
            try:
                inner_sample = np.append(np.random.permutation(sample),
                                         np.random.randint(0, sample.shape[0], sample.shape[0]).reshape(sample.shape[0],
                                                                                                        1), axis=1)
                inner_sample = inner_sample[np.argsort(inner_sample[:, -1], kind="stable")]
                wrw = ev.weighted_reindeer_weariness_new(inner_sample)
                wrw_list[0] = wrw
                sbest_list.append(inner_sample)
                break
            except Exception as error:
                print(error)
                continue

        # Generate a list containing the maximum number of solutions and WRW
        # The solution is generated by random selection
        # Use while loop and try except to deal with the weight limit error
        for i in range(maximum_number):
            while True:
                try:
                    sample_new = np.append(np.random.permutation(sample),
                                           np.random.randint(0, sample.shape[0], sample.shape[0]).reshape(
                                               sample.shape[0], 1), axis=1)
                    sample_new = sample_new[np.argsort(sample_new[:, -1], kind="stable")]
                    wrw_new = ev.weighted_reindeer_weariness_new(sample_new)
                    wrw_list[i + 1] = wrw_new
                    sbest_list.append(sample_new)
                    break
                except Exception as error:
                    print(error)
                    continue

        # Find the best solution in a random seed and append it to the list
        inner_wrw_list[s] = np.min(wrw_list)
        inner_sbest_list.append(sbest_list[np.argmin(wrw_list)][:, [0, 4]])
    return inner_wrw_list, inner_sbest_list


# run code for random_search function
start_time = timer()

outer_wrw_list, outer_sbest_list = random_search(sample1, 1000)
wrw_list_df = pd.DataFrame(outer_wrw_list)
print(wrw_list_df.describe())

end_time = timer()
print("(Time: {:.2f} seconds)".format(end_time - start_time))


# NM1 Exchange positions of two gifts in the same trip
def exchange_positions(sample, index, counts):
    # Check if the number of gifts in all trips are less than 2,
    # when it is not possible to select a trip to change the position of the gifts
    if np.all(counts < 2):
        return sample
    else:
        sample_new = sample.copy()

        # Use the while loop to solve the case where the selected trip contains only one gift
        gift_number = 1

        while gift_number <= 1:
            trip = np.random.choice(range(0, len(counts) - 1), 1, replace=False)[0]
            gift_number = counts[trip]
        else:
            exchange_index = np.random.choice(range(index[trip], index[trip] + gift_number), 2, replace=False)
            sample_new[[exchange_index[0], exchange_index[1]], :] = sample_new[[exchange_index[1], exchange_index[0]], :]

            return sample_new


# Algorithm 2: Simulated Annealing with NM1
def simulated_annealing_nm1(sample, maximum_number, a=0.95):
    """
    Use NM1 as an iteration to approximating the global optimum
    """
    # Create empty array and list to store the best WRW and solution returned by each run (30 values in total)
    inner_wrw_list = np.zeros(30)
    inner_sbest_list = []

    # Collect 30 results with different random seed
    for s in range(30):
        np.random.seed(s)
        inner_sample = sample.copy()
        T = 1

        # Generate the first solution randomly ant calculate the WRW
        # Use while loop and try except to deal with the weight limit error
        while True:
            try:
                np.random.shuffle(inner_sample)
                inner_sample = np.append(inner_sample,
                                         np.random.randint(0, inner_sample.shape[0], inner_sample.shape[0]).reshape(
                                             inner_sample.shape[0], 1), axis=1)
                inner_sample = inner_sample[np.argsort(inner_sample[:, -1], kind="stable")]
                uniq_trips, index, counts = np.unique(inner_sample[:, -1], return_index=True, return_counts=True)
                wrw = ev.weighted_reindeer_weariness_new(inner_sample)
                break
            except Exception as error:
                print(error)
                continue

        # Generate a list containing the maximum number of solutions and WRW
        # Use NM1 as an iteration
        for _ in range(maximum_number):
            # Exchange positions of two gifts in the same trip
            sample_new = exchange_positions(inner_sample, index, counts)
            wrw_new = ev.weighted_reindeer_weariness_new(sample_new)

            # Use the following equation to determine whether we have to accept the interation
            # Round the number to 4 decimal places to avoid the difference among different laptops
            # which may cause the different results
            if float(format(wrw_new, '.4f')) < float(format(wrw, '.4f')) or np.random.random() < np.exp(
                    1 / T * (float(format(wrw, '.4f')) - float(format(wrw_new, '.4f'))) / float(format(wrw, '.4f'))):
                wrw = wrw_new
                inner_sample = sample_new.copy()
            T = a * T

        # Find the best solution in a random seed and append it to the list
        inner_wrw_list[s] = wrw
        inner_sbest_list.append(inner_sample[:, [0, 4]])

    return inner_wrw_list, inner_sbest_list


# run code for simulated_annealing_nm1 function
start_time = timer()

outer_wrw_list, outer_sbest_list = simulated_annealing_nm1(sample1, 1000)
wrw_list_df = pd.DataFrame(outer_wrw_list)
print(wrw_list_df.describe())

end_time = timer()
print("(Time: {:.2f} seconds)".format(end_time - start_time))


# NM6 Three-way suffix swap
def three_way_suffix_swap(sample, index, counts):
    # Check if the number of trips are less than 3,
    # when it is not possible to select 3 trips to change the position of the gifts
    if len(counts) > 2:
        sample_new = sample.copy()
        trips = np.random.choice(range(0, len(counts) - 1), 3, replace=False)

        # sort the selected trips by index in order to split array correctly
        index_array = np.sort(np.array([index[trips[0]], index[trips[1]], index[trips[2]]]))
        index_trip1 = index_array[0]
        index_trip2 = index_array[1]
        index_trip3 = index_array[2]

        count_trip1 = counts[np.where(index == index_trip1)[0][0]]
        count_trip2 = counts[np.where(index == index_trip2)[0][0]]
        count_trip3 = counts[np.where(index == index_trip3)[0][0]]

        tripid_1 = sample_new[index_trip1, 4]
        tripid_2 = sample_new[index_trip2, 4]
        tripid_3 = sample_new[index_trip3, 4]

        # the first trip
        gift_1 = np.random.choice(range(index_trip1, index_trip1 + count_trip1), 1, replace=False)[0]
        sample_new[gift_1:index_trip1 + count_trip1, 4] = tripid_3

        # the second trip
        gift_2 = np.random.choice(range(index_trip2, index_trip2 + count_trip2), 1, replace=False)[0]
        sample_new[gift_2:index_trip2 + count_trip2, 4] = tripid_1

        # the third trip
        gift_3 = np.random.choice(range(index_trip3, index_trip3 + count_trip3), 1, replace=False)[0]
        sample_new[gift_3:index_trip3 + count_trip3, 4] = tripid_2

        # split the array and concatenate them by correct order
        array_part1, array_part2, array_part3, array_part4, array_part5, array_part6, array_part7 = \
            np.split(sample_new, [gift_1, index_trip1 + count_trip1, gift_2, index_trip2 + count_trip2,
                                  gift_3, index_trip3 + count_trip3])
        sample_new = np.concatenate(
            (array_part1, array_part4, array_part3, array_part6, array_part5, array_part2, array_part7))

        return sample_new

    else:
        return sample


# Algorithm 2: Simulated Annealing with NM1&NM6
def simulated_annealing_nm1_nm6(sample, maximum_number, a=0.95):
    """
    Use NM1 or NM6 as an iteration to approximating the global optimum
    """
    # Create empty array and list to store the best WRW and solution returned by each run (30 values in total)
    inner_wrw_list = np.zeros(30)
    inner_sbest_list = []

    # Collect 30 results with different random seed
    for s in range(30):
        np.random.seed(s)
        inner_sample = sample.copy()
        T = 1

        # Generate the first solution randomly ant calculate the WRW
        # Use while loop and try except to deal with the weight limit error
        while True:
            try:
                np.random.shuffle(inner_sample)
                inner_sample = np.append(inner_sample,
                                         np.random.randint(0, inner_sample.shape[0], inner_sample.shape[0]).reshape(
                                             inner_sample.shape[0], 1), axis=1)
                inner_sample = inner_sample[np.argsort(inner_sample[:, -1], kind="stable")]
                uniq_trips, index, counts = np.unique(inner_sample[:, -1], return_index=True, return_counts=True)
                wrw = ev.weighted_reindeer_weariness_new(inner_sample)
                break
            except Exception as error:
                print(error)
                continue

        # Generate a list containing the maximum number of solutions and WRW
        for _ in range(maximum_number):
            # Use NM1 as an iteration and get the WRW
            sample_nm1 = exchange_positions(inner_sample, index, counts)
            wrw_nm1 = ev.weighted_reindeer_weariness_new(sample_nm1)

            # Use NM6 as an iteration and get the WRW
            # Use while loop and try except to deal with the weight limit error
            while True:
                try:
                    sample_nm6 = three_way_suffix_swap(sample_nm1, index, counts)
                    wrw_nm6 = ev.weighted_reindeer_weariness_new(sample_nm6)
                    break
                except Exception as error:
                    print(error)
                    continue

            # compare WRW of NM1 and NM6 to decide which iteration to use
            # Round the number to 4 decimal places to avoid the difference among different laptops
            # which may cause the different results
            if float(format(wrw_nm6, '.4f')) < float(format(wrw_nm1, '.4f')):

                # Use the following equation to determine whether we have to accept the interation
                if float(format(wrw_nm6, '.4f')) < float(format(wrw, '.4f')) or np.random.random() < np.exp(
                        1 / T * (float(format(wrw, '.4f')) - float(format(wrw_nm6, '.4f'))) / float(
                                format(wrw, '.4f'))):
                    wrw = wrw_nm6
                    inner_sample = sample_nm6.copy()
                    uniq_trips, index, counts = np.unique(inner_sample[:, -1], return_index=True, return_counts=True)

            else:
                # Use the following equation to determine whether we have to accept the interation
                if float(format(wrw_nm1, '.4f')) < float(format(wrw, '.4f')) or np.random.random() < np.exp(
                        1 / T * (float(format(wrw, '.4f')) - float(format(wrw_nm1, '.4f'))) / float(
                                format(wrw, '.4f'))):
                    wrw = wrw_nm1
                    inner_sample = sample_nm1.copy()

            T = a * T

        # Find the best solution in a random seed and append it to the list
        inner_wrw_list[s] = wrw
        inner_sbest_list.append(inner_sample[:, [0, 4]])

    return inner_wrw_list, inner_sbest_list


# run code for simulated_annealing_nm1_NM6 function
start_time = timer()

outer_wrw_list, outer_sbest_list = simulated_annealing_nm1_nm6(sample1, 1000)
wrw_list_df = pd.DataFrame(outer_wrw_list)
print(wrw_list_df.describe())

end_time = timer()
print("(Time: {:.2f} seconds)".format(end_time - start_time))


# Task4: create box plots for three algorithms
def box_plots_task4(sample, maximum_number, name):
        wrw_list1, sbest_list1 = random_search(sample, maximum_number)
        wrw_list2, sbest_list2 = simulated_annealing_nm1(sample, maximum_number)
        wrw_list3, sbest_list3 = simulated_annealing_nm1_nm6(sample, maximum_number)

        wrw_list_df1 = pd.DataFrame(wrw_list1)
        wrw_list_df2 = pd.DataFrame(wrw_list2)
        wrw_list_df3 = pd.DataFrame(wrw_list3)

        data_sample = pd.concat([wrw_list_df1, wrw_list_df2, wrw_list_df3], axis=1)
        data_sample.columns = ['RS', 'SA with NM1', 'SA with NM1&NM6']

        plt.figure(figsize=(20, 5), facecolor='lightgray')
        data_sample.plot.box(sym='+')
        plt.title('WRW of {:s}'.format(name), fontsize=10)
        plt.tight_layout()
        plt.show()


# input different sample to get the boxplot
box_plots_task4(sample1, 1000, "Sample1")


# Task5: visualize the effect of varying the above parameter on the WRW values of the datasets
def box_plots_task5(sample, algorithm, maximum_number, input_a_list, name):
    wrw_list_rs, sbest_list_rs = random_search(sample, maximum_number)
    wrw_list_sa_a1, sbest_list_sa_a1 = algorithm(sample, 1000, input_a_list[0])
    wrw_list_sa_a2, sbest_list_sa_a2 = algorithm(sample, maximum_number, input_a_list[1])
    wrw_list_sa_a3, sbest_list_sa_a3 = algorithm(sample, maximum_number, input_a_list[2])
    wrw_list_sa_a4, sbest_list_sa_a4 = algorithm(sample, maximum_number, input_a_list[3])
    wrw_list_sa_a5, sbest_list_sa_a5 = algorithm(sample, maximum_number, input_a_list[4])

    plt.figure(figsize=(10, 5))
    plt.title('Boxplot of {:s} with different a compared with RS'.format(name), fontsize=10)
    labels = 'random search', 'a=0.5', 'a=0.8', 'a=0.90', 'a=0.95', 'a=0.98'
    plt.boxplot([wrw_list_rs, wrw_list_sa_a1, wrw_list_sa_a2, wrw_list_sa_a3, wrw_list_sa_a4, wrw_list_sa_a5],
                labels=labels, showfliers=False, showmeans=True, meanline=True)
    plt.style.use('ggplot')
    plt.show()


# Input different sample to get the boxplot
# Because when a equals to 0.5, if we use a large maximum number the Simulated Annealing Algorithm will return an error,
# we tend to use 1000 as the maximum number to avoid it.
a_list = [0.5, 0.8, 0.9, 0.95, 0.98]
box_plots_task5(sample1, simulated_annealing_nm1_nm6, 1000, a_list, "Simulated Annealing with NM1&NM6")


# Task6: Run the best algorithm for the original dataset by XX times and report the best WRW value found
gifts = np.array(gifts)
outer_wrw_list, outer_sbest_list = simulated_annealing_nm1_nm6(gifts, 56789)
wrw_list_df = pd.DataFrame(outer_wrw_list)
print(wrw_list_df.describe())
print("The best WRW:", np.min(outer_wrw_list))


# The alternative function for Random Search which uses multiprocessing package to speed up
# The limitation of this function is that we do not know how to deal with
# the weight limit error in multiprocessing package
def random_search_multiprocessing(sample, maximum_number):
    """
    Generate different solution randomly and compare wrw to find the best solution
    """
    # Create empty array and list to store the best WRW and solution returned by each run (30 values in total)
    inner_wrw_list = np.zeros(30)
    inner_sbest_list = []

    # Collect 30 results with different random seed
    for s in range(30):
        np.random.seed(s)

        # Generate the first solution randomly ant calculate the WRW
        first_solution = np.append(np.random.permutation(sample),
                                   np.random.randint(0, sample.shape[0], sample.shape[0]).reshape(sample.shape[0], 1),
                                   axis=1)
        first_solution = first_solution[np.argsort(first_solution[:, -1], kind="stable")]
        first_wrw = ev.weighted_reindeer_weariness_new(first_solution)

        # Generate a list containing the maximum number of solutions and WRW
        # The solution is generated by random selection
        solution_list = [np.append(np.random.permutation(sample),
                                   np.random.randint(0, sample.shape[0], sample.shape[0]).reshape(sample.shape[0], 1),
                                   axis=1) for _ in range(maximum_number)]
        solution_list = [i[np.argsort(i[:, -1], kind="stable")] for i in solution_list]
        pool = mp.Pool()
        wrw_list = pool.map(ev.weighted_reindeer_weariness_new, solution_list)
        wrw_list = np.insert(wrw_list, 0, first_wrw)
        solution_list.insert(0, first_solution)

        # Find the best solution in a random seed and append it to the list
        inner_wrw_list[s] = np.min(wrw_list)
        inner_sbest_list.append(solution_list[np.argmin(wrw_list)][:, [0, 4]])
    return inner_wrw_list, inner_sbest_list

# run code for random_search_multiprocessing function
# if __name__ == '__main__':
    start_time = timer()

    outer_wrw_list, outer_sbest_list = random_search_multiprocessing(sample1, 100)
    wrw_list_df = pd.DataFrame(outer_wrw_list)
    print(wrw_list_df.describe())

    end_time = timer()
    print("(Time: {:.2f} seconds)".format(end_time - start_time))
